diff --git a/esm/index.js b/esm/index.js
index bb5a84ac08ddf9ed68e3bb8c98232d970f90d9e9..5aeb26d1c20c6ffca66bcb769d14663b23de7b76 100644
--- a/esm/index.js
+++ b/esm/index.js
@@ -6,12 +6,13 @@ import { concatUint8Arrays } from 'typed-array-utils';
 import { aMap, aJoin, collect, promiseToStream } from './iter.js';
 const maybeAsyncIterToStream = (x) => x instanceof ReadableStream ? x : asyncIterToStream(x);
 const maybeStreamToAsyncIter = (x) => x instanceof ReadableStream ? streamToAsyncIter(x) : x;
+const isWWWS = '@web-widget/web-std' in globalThis;
 // FIXME: add exception for newer versions that support streams correctly!?
 const isCFWorkers = ((_b = (_a = globalThis.navigator) === null || _a === void 0 ? void 0 : _a.userAgent) === null || _b === void 0 ? void 0 : _b.includes('Cloudflare-Workers'))
     || !('TextEncoderStream' in dntShim.dntGlobalThis);
 // CF Workers doesn't support non-binary Transform Streams, 
 // so we use a version that does the byte encoding in a async iterator instead:
-const stringStreamToByteStream = isCFWorkers
+const stringStreamToByteStream = isCFWorkers || isWWWS
     ? body => {
         const encoder = new TextEncoder();
         return asyncIterToStream(aMap(maybeStreamToAsyncIter(body), x => encoder.encode(x)));
diff --git a/src/index.ts b/src/index.ts
index 02a75971f327589d7d33d61a9ef9e8e7d92cfa3b..0c48975e162da61cf799659490f63b12e7e9b1a4 100644
--- a/src/index.ts
+++ b/src/index.ts
@@ -14,13 +14,15 @@ const maybeAsyncIterToStream = <T>(x: ForAwaitable<T> | ReadableStream<T>) =>
 const maybeStreamToAsyncIter = <T>(x: ForAwaitable<T> | ReadableStream<T>) =>
   x instanceof ReadableStream ? streamToAsyncIter(x) : x;
 
+const isWWWS = "@web-widget/web-std" in globalThis;
+
 // FIXME: add exception for newer versions that support streams correctly!?
 const isCFWorkers = (<any>globalThis.navigator)?.userAgent?.includes('Cloudflare-Workers')
   || !('TextEncoderStream' in dntShim.dntGlobalThis)
 
 // CF Workers doesn't support non-binary Transform Streams, 
 // so we use a version that does the byte encoding in a async iterator instead:
-const stringStreamToByteStream: (body: StreamBodyInit) => ReadableStream<Uint8Array> = isCFWorkers
+const stringStreamToByteStream: (body: StreamBodyInit) => ReadableStream<Uint8Array> = isCFWorkers || isWWWS
   ? body => {
     const encoder = new TextEncoder();
     return asyncIterToStream(aMap(maybeStreamToAsyncIter(body), x => encoder.encode(x)))